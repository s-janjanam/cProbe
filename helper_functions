# coding=utf-8
# !/usr/bin/python

"""
    This module implements various helper functions relevant for cprobe.
    Derived from src/cstor/src/HelperFunctions.py
"""
from gevent import monkey
monkey.patch_all()

import os
import sys
from logging import WARN, INFO, ERROR, DEBUG, CRITICAL
import gevent
from gevent import subprocess
import traceback # For run_cmd_e if needed, or general error handling

# Import Consts from the local constants.py module
from .constants import Consts

# Global logger is removed. Functions should accept a logger instance.

base_image = None # Global for baseimage()

def read_base_image_file(logger_obj=None): # Added logger_obj for consistency
    global base_image
    # Using Consts.BASEIMAGE_FILE from the imported .constants
    if base_image is None:
        base_image = 1804 # Default value
        try:
            if logger_obj:
                logger_obj.debug("Reading base image file at: {}".format(Consts.BASEIMAGE_FILE))
            with open(Consts.BASEIMAGE_FILE, 'r') as base_image_fd:
                lines = base_image_fd.readlines()
                for line in lines:
                    if '1804' in line:
                        base_image = 1804
                        break
        except IOError:
            if logger_obj:
                logger_obj.warn("Base-image file is missing or unreadable at {}, assuming 1804".format(Consts.BASEIMAGE_FILE))
            pass # Silently use default if file not found or not 1804
    return base_image

def baseimage(logger_obj=None): # Added logger_obj
    return read_base_image_file(logger_obj=logger_obj)

def run_cmd(cmd, use_gevent=False, logger_obj=None): # Added logger_obj
    if logger_obj:
        logger_obj.debug("Running command: {}".format(cmd))
    popen = subprocess.Popen if not use_gevent else gevent.subprocess.Popen
    p = popen(cmd, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    sout, serr = p.communicate()
    rc = p.returncode
    if logger_obj:
        logger_obj.debug(f"run_cmd: rc={rc}, serr='{serr.decode(errors='ignore')}', sout='{sout.decode(errors='ignore')}'")
    return rc, serr, sout

# run command and handle error
def run_cmd_e(cmd, logger_obj=None): # Added logger_obj
    try:
        rc, serr, sout = run_cmd(cmd, logger_obj=logger_obj)
        sout = sout.decode('utf8')
        serr = serr.decode('utf8')
        if rc != 0:
            raise Exception(sout + serr)
    except Exception as e:
        if logger_obj:
            logger_obj.error("Error running cmd: {}\n{}".format(cmd, str(e)))
        raise # Re-raise the exception to be handled by the caller
    return sout

def upstart_to_systemd_process_name(process, logger_obj=None):
    # Simplified version for cprobe.
    # Assumes Consts would be imported if needed for SYSD_PROCESSES/CPROBE_PROCESSES checks.
    # Consts is now imported from .constants.
    # The check for process in Consts.SYSD_PROCESSES + Consts.CPROBE_PROCESSES can be re-enabled if needed.

    if 'mongod' in process:
        process = 'mongodb'
    elif 'ntp' in process:
        process = 'chrony'
    elif 'pcap' in process:
        process = process.replace('-', '@')

    # Removed capture_mode dependent logic for dpdk_snf/cstor_snf
    # if capture_mode in [None, 'myricom', 'cprobe', 'libpcap']:
    #     if 'dpdk_snf' in process:
    #         process = 'cstor_snf'
    #         if capture_mode == 'cprobe' and log:
    #             log.error("Unexpected action to handle dpdk_snf in cProbe mode")
    # elif capture_mode == 'dpdk':
    #     if 'cstor_snf' in process:
    #         process = 'dpdk_snf'

    # Assuming Consts.SYSD_PROCESSES and Consts.CPROBE_PROCESSES will be defined appropriately
    # The check against Consts.SYSD_PROCESSES + Consts.CPROBE_PROCESSES.
    # Consts.SYSD_PROCESSES is not in cprobe.constants yet. If this check is vital,
    # SYSD_PROCESSES should be added to cprobe.constants or this logic reconsidered.
    # For now, keeping it commented as it was.
    # if process not in Consts.SYSD_PROCESSES + Consts.CPROBE_PROCESSES:
    #     if logger_obj:
    #         logger_obj.error("The process: {} is not valid for control".format(process))
    #     return None
    return process

def control_process(process, action, logger_obj=None):
    rc = 1
    if logger_obj:
        logger_obj.debug("trying to {} the {} process".format(action, process))

    # Pass logger_obj to baseimage
    current_base_image = baseimage(logger_obj=logger_obj)
    if current_base_image == 1804:
        if action not in ['start', 'stop', 'restart', 'enable', 'disable']:
            if logger_obj:
                logger_obj.error("The action: {} is not valid for systemd operations".format(action))
            return rc

        process = upstart_to_systemd_process_name(process, logger_obj=logger_obj)
        if process is None:
            return rc
        my_cmd = "systemctl {} {} ".format(action, process)
    else:
        if logger_obj:
            logger_obj.error("Unsupported baseimage : {}".format(current_base_image))
        return rc

    # Pass logger_obj to run_cmd
    rc_cmd, serr_cmd, sout_cmd = run_cmd(my_cmd, logger_obj=logger_obj)

    if rc_cmd != 0 or serr_cmd != b'': # Python 3: stderr is bytes
        if logger_obj:
            logger_obj.debug("control process {}: RC={} stderr: {}".format(process, rc_cmd, serr_cmd.decode(errors='ignore')))
    return rc_cmd # Return the actual return code of the command

def rm_files_in_dir(d_name, skip_files=[], logger_obj=None): # Added logger_obj
    rm_list = []
    if not os.path.isdir(d_name):
        if logger_obj:
            logger_obj.warn(f"Directory {d_name} does not exist for rm_files_in_dir.")
        return rm_list
    for item in os.listdir(d_name):
        item_path = os.path.join(d_name, item)
        if os.path.isfile(item_path) and item not in skip_files:
            try:
                os.remove(item_path)
                rm_list.append(item_path)
                if logger_obj:
                    logger_obj.debug(f"Removed file: {item_path}")
            except Exception as e:
                if logger_obj:
                    logger_obj.error("Failed to remove {}: {}".format(item_path, e))
    return rm_list

def makedirs(d_name, exist_ok=False, logger_obj=None): # Added logger_obj
    try:
        if not os.path.isdir(d_name):
            os.makedirs(d_name)
            if logger_obj:
                logger_obj.debug(f"Created directory: {d_name}")
        elif not exist_ok:
            # Directory exists but exist_ok is False, this is technically an error condition for os.makedirs
            if logger_obj:
                logger_obj.warn(f"Directory {d_name} already exists and exist_ok is False.")
            # os.makedirs would raise FileExistsError here. Mimic or let it be?
            # For now, just log. The original code was `if not os.path.isdir(d_name) or not exist_ok: os.makedirs(d_name)`
            # which means it would only call os.makedirs if dir does not exist OR if exist_ok is False.
            # This logic is a bit confusing. Standard os.makedirs(d_name, exist_ok=True) is clearer.
            # Let's stick to: make dir if not exists. If it exists & exist_ok=False, it's an issue.
            # However, the original `os.makedirs(d_name)` without exist_ok implies exist_ok=False.
            # Replicating the original logic:
            # if not os.path.isdir(d_name) or not exist_ok:
            # os.makedirs(d_name) # This will fail if d_name is a file or if path is invalid.
            pass # Covered by the `if not os.path.isdir(d_name):` above for creation.
                 # If it is a dir and exist_ok is False, original code did nothing.

    except Exception as e:
        if logger_obj:
            logger_obj.error("Failed to create directory {}: {}".format(d_name, e))
        # Optionally re-raise
        raise

def remove_file(f_name, ignore_missing=False, logger_obj=None): # Added logger_obj
    if not os.path.exists(f_name):
        if not ignore_missing:
            if logger_obj:
                logger_obj.warn(f"File {f_name} does not exist and ignore_missing is False.")
            # Potentially raise an error here if that's desired behavior
        return
    try:
        os.remove(f_name)
        if logger_obj:
            logger_obj.debug(f"Removed file: {f_name}")
    except Exception as e:
        if logger_obj:
            logger_obj.error("Failed to remove file {}: {}".format(f_name, str(e)))
        # Optionally re-raise
        raise

if __name__ == "__main__":
    sys.exit("not supposed to run as a main module")
# No specific else block needed here, module can be imported.
